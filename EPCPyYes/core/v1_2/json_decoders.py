# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2019 SerialLab Corp.  All rights reserved.
from uuid import uuid4
from EPCPyYes.core.v1_2.events import QuantityElement, ErrorDeclaration, \
    Source, SourceDest, Destination, BusinessTransaction, \
    InstanceLotMasterDataAttribute
from EPCPyYes.core.v1_2.template_events import AggregationEvent, ObjectEvent, \
    TransactionEvent, TransformationEvent
from json import JSONDecoder, decoder, loads
from collections import namedtuple


class ChildQuantityMixin:
    """
    Mixin to support deserializing json quantity lists to EPCPyYes
    types.
    """
    def decode_child_quantity_list(self, child_quantity_list):
        ret = []
        if child_quantity_list:
            for child_quantity in child_quantity_list:
                child_quantity = namedtuple('Quantity', child_quantity.keys())(
                    *child_quantity.values()
                )
                ret.append(
                    QuantityElement(
                        epc_class=getattr(child_quantity, 'epcClass'),
                        quantity=getattr(child_quantity, 'quantity'),
                        uom=getattr(child_quantity, 'uom')
                    )
                )
        return ret


class ErrorDeclarationMixin:
    """
    Deserializes a JSON error declaration to an EPCPyYes ErrorDeclaration.
    """
    def decode_error_declaration(self, error_declaration):
        if error_declaration:
            error_declaration = namedtuple(
                'ErrorDeclaration', error_declaration.keys()) \
                (*error_declaration.values())
            return ErrorDeclaration(
                declaration_time=error_declaration.declarationTime,
                reason=error_declaration.reason,
                corrective_event_ids=getattr(error_declaration,
                                             'correctiveEventIDs'),
            )


class SourceListMixin:
    """
    Deserializes a JSON source list to an EPCPyYes SourceList
    """
    def decode_source_list(self, source_list):
        ret = []
        if source_list:
            for source, value in source_list.items():
                ret.append(
                    Source(
                        source,
                        value
                    )
                )
            return ret


class DestinationListMixin:
    """
    Deserializes a JSON destination list to an EPCPyYes Destination List.
    """
    def decode_destination_list(self, destination_list):
        ret = []
        if destination_list:
            for destintation, value in destination_list.items():
                ret.append(
                    Destination(
                        destintation,
                        value
                    )
                )
            return ret


class BusinessTransactionListMixin:
    """
    Deserializes a JSON transaction list to a EPCPyYes BusinessTransaction
    list.
    """
    def decode_business_transaction_list(self, biz_transaction_list):
        if biz_transaction_list:
            ret = []
            for xact, xact_type in biz_transaction_list.items():
                ret.append(
                    BusinessTransaction(
                        xact,
                        xact_type
                    )
                )
            return ret


class ILMDMixin:
    def decode_ilmd(self, ilmd):
        if ilmd:
            ret = []
            for name, value in ilmd.items():
                ret.append(
                    InstanceLotMasterDataAttribute(
                        name,
                        value
                    )
                )
            return ret


class ObjectEventDecoder(
    ChildQuantityMixin,
    ErrorDeclarationMixin,
    SourceListMixin,
    DestinationListMixin,
    BusinessTransactionListMixin,
    ILMDMixin
):
    """
    Will deserialize JSON structures generated by the EPCPyYes
    render_json and render_pretty_json functions on the template_event
    class.  This basically turns JSON EPCPyYes back into it's native
    EPCPyYes python base class.

    Usage.

    .. code-block: python

        # this returns an EPCPyYes.core.v1_2.template_events.ObjectEvent
        objevent = ObjectEventDecoder(data).get_event()

    """
    def __init__(self, payload: dict) -> None:
        if isinstance(payload, str):
            self.__dict__ = loads(payload)['objectEvent']
        elif isinstance(payload, dict):
            self.__dict__ = payload['objectEvent']
        else:
            raise TypeError('Input payload must be a string or a dictionary.')

    def get_event(self):
        obj_event = ObjectEvent(
            self.eventTime,
            getattr(self, 'eventTimezoneOffset'),
            getattr(self, 'recordTime', None),
            self.action,
            epc_list=getattr(self, 'epcList', []),
            quantity_list=self.decode_child_quantity_list(
                getattr(self, 'quantityList')
            ),
            biz_step=getattr(self, 'bizStep'),
            disposition=getattr(self, 'disposition'),
            read_point=getattr(self, 'readPoint'),
            biz_location=getattr(self, 'bizLocation'),
            event_id=getattr(self, 'eventID'),
            error_declaration=self.decode_error_declaration(
                getattr(self, 'errorDeclaration')
            ),
            source_list=self.decode_source_list(
                getattr(self, 'sourceList')
            ),
            destination_list=self.decode_destination_list(
                getattr(self, 'destinationList')
            ),
            business_transaction_list=self.decode_business_transaction_list(
                getattr(self, 'bizTransactionList')
            ),
            ilmd=self.decode_ilmd(
                getattr(self, 'ilmd')
            )
        )
        obj_event.id = str(uuid4())
        return obj_event


class AggregationEventDecoder(
    ChildQuantityMixin,
    ErrorDeclarationMixin,
    SourceListMixin,
    DestinationListMixin,
    BusinessTransactionListMixin
):
    """
    Will deserialize JSON structures generated by the EPCPyYes
    render_json and render_pretty_json functions on the template_event
    class.  This basically turns JSON EPCPyYes back into it's native
    EPCPyYes python base class.

    Usage.

    .. code-block: python

        # this returns an EPCPyYes.core.v1_2.template_events.AggregationEvent
        aggevent = AggregationEventDecoder(data).get_event()

    """
    def __init__(self, payload: dict) -> None:
        if isinstance(payload, str):
            self.__dict__ = loads(payload)['aggregationEvent']
        elif isinstance(payload, dict):
            self.__dict__ = payload['aggregationEvent']
        else:
            raise TypeError('Input payload must be a string or a dictionary.')

    def get_event(self):
        agg_event = AggregationEvent(
            self.eventTime,
            getattr(self, 'eventTimezoneOffset'),
            getattr(self, 'recordTime', None),
            self.action,
            parent_id=getattr(self, 'parentID', None),
            child_epcs=getattr(self, 'childEPCs', []),
            child_quantity_list=self.decode_child_quantity_list(
                getattr(self, 'childQuantityList')
            ),
            biz_step=getattr(self, 'bizStep'),
            disposition=getattr(self, 'disposition'),
            read_point=getattr(self, 'readPoint'),
            biz_location=getattr(self, 'bizLocation'),
            event_id=getattr(self, 'eventID'),
            error_declaration=self.decode_error_declaration(
                getattr(self, 'errorDeclaration')
            ),
            source_list=self.decode_source_list(
                getattr(self, 'sourceList')
            ),
            destination_list=self.decode_destination_list(
                getattr(self, 'destinationList')
            ),
            business_transaction_list=self.decode_business_transaction_list(
                getattr(self, 'bizTransactionList')
            ),
        )
        agg_event.id = str(uuid4())
        return agg_event


class TransactionEventDecoder(
    ChildQuantityMixin,
    ErrorDeclarationMixin,
    SourceListMixin,
    DestinationListMixin,
    BusinessTransactionListMixin
):
    """
    Will deserialize JSON structures generated by the EPCPyYes
    render_json and render_pretty_json functions on the template_event
    class.  This basically turns JSON EPCPyYes back into it's native
    EPCPyYes python base class.

    Usage.

    .. code-block: python

        # this returns an EPCPyYes.core.v1_2.template_events.TransactionEvent
        tevent = TransactionEventDecoder(data).get_event()

    """
    def __init__(self, payload) -> None:
        if isinstance(payload, str):
            self.__dict__ = loads(payload)['transactionEvent']
        elif isinstance(payload, dict):
            self.__dict__ = payload['transactionEvent']
        else:
            raise TypeError('Input payload must be a string or a dictionary.')

    def get_event(self):
        xact_event = TransactionEvent(
            self.eventTime,
            getattr(self, 'eventTimezoneOffset'),
            getattr(self, 'recordTime', None),
            self.action,
            parent_id=getattr(self, 'parentID', None),
            epc_list=getattr(self, 'epcList', []),
            quantity_list=self.decode_child_quantity_list(
                getattr(self, 'quantityList')
            ),
            biz_step=getattr(self, 'bizStep'),
            disposition=getattr(self, 'disposition'),
            read_point=getattr(self, 'readPoint'),
            biz_location=getattr(self, 'bizLocation'),
            event_id=getattr(self, 'eventID'),
            error_declaration=self.decode_error_declaration(
                getattr(self, 'errorDeclaration')
            ),
            source_list=self.decode_source_list(
                getattr(self, 'sourceList')
            ),
            destination_list=self.decode_destination_list(
                getattr(self, 'destinationList')
            ),
            business_transaction_list=self.decode_business_transaction_list(
                getattr(self, 'bizTransactionList')
            )
        )
        xact_event.id = str(uuid4())
        return xact_event